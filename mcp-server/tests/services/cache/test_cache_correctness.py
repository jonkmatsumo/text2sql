"""Unit tests for cache correctness, collision prevention, and validation."""

from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from mcp_server.services.cache.constraint_extractor import extract_constraints
from mcp_server.services.cache.intent_signature import build_signature_from_constraints
from mcp_server.services.cache.service import lookup_cache


@pytest.mark.parametrize(
    "query,expected_limit,expected_sort",
    [
        ("10 longest PG movies", 10, "DESC"),
        ("ten shortest G films", 10, "ASC"),
        ("top 5 highest rated actors", 5, "DESC"),
        ("lowest 3 metrics", 3, "ASC"),
    ],
)
def test_improved_constraint_extraction(query, expected_limit, expected_sort):
    """G3: Verify improved limit and sort extraction."""
    constraints = extract_constraints(query)
    assert constraints.limit == expected_limit
    assert constraints.sort_direction == expected_sort


def test_canonical_collision_prevention():
    """G1: Verify 'longest' and 'shortest' have different fingerprints."""
    q1 = "10 longest PG movies"
    q2 = "10 shortest PG movies"

    c1 = extract_constraints(q1)
    c2 = extract_constraints(q2)

    assert c1.sort_direction == "DESC"
    assert c2.sort_direction == "ASC"

    sig1 = build_signature_from_constraints(
        q1,
        rating=c1.rating,
        limit=c1.limit,
        sort_direction=c1.sort_direction,
        entity=c1.entity,
        metric=c1.metric,
    )
    sig2 = build_signature_from_constraints(
        q2,
        rating=c2.rating,
        limit=c2.limit,
        sort_direction=c2.sort_direction,
        entity=c2.entity,
        metric=c2.metric,
    )

    key1 = sig1.compute_key()
    key2 = sig2.compute_key()

    assert key1 != key2, "Fingerprints should differ for opposing sort directions"


@pytest.mark.asyncio
async def test_tier1_validation_enforcement():
    """G2: Verify Tier-1 cache hits are validated and rejected if incorrect."""
    user_query = "10 longest PG movies"
    # Cached SQL is for SHORTEST (ASC)
    cached_sql = "SELECT title FROM film WHERE rating = 'PG' ORDER BY length ASC LIMIT 10"

    mock_pair = MagicMock()
    mock_pair.signature_key = "dummy_key"
    mock_pair.sql_query = cached_sql
    mock_pair.roles = ["cache"]
    mock_pair.status = "autogenerated"

    with patch(
        "mcp_server.services.cache.service.RegistryService.lookup_canonical", new_callable=AsyncMock
    ) as mock_lookup:
        mock_lookup.return_value = mock_pair

        # Mock lookup_semantic to avoid falling through to a miss
        # when we want to confirm rejection
        with patch(
            "mcp_server.services.cache.service.RegistryService.lookup_semantic",
            new_callable=AsyncMock,
        ) as mock_semantic:
            mock_semantic.return_value = []

            result = await lookup_cache(user_query, tenant_id=1)

            msg = "Tier-1 hit should be rejected due to sort direction mismatch"
            assert result is None, msg


@pytest.mark.asyncio
async def test_tier1_validation_success():
    """G2: Verify Tier-1 cache hits are returned if valid."""
    user_query = "10 longest PG movies"
    # Cached SQL is for LONGEST (DESC)
    cached_sql = "SELECT title FROM film WHERE rating = 'PG' ORDER BY length DESC LIMIT 10"

    mock_pair = MagicMock()
    mock_pair.signature_key = "correct_key"
    mock_pair.sql_query = cached_sql
    mock_pair.roles = ["cache"]
    mock_pair.status = "autogenerated"

    with patch(
        "mcp_server.services.cache.service.RegistryService.lookup_canonical", new_callable=AsyncMock
    ) as mock_lookup:
        mock_lookup.return_value = mock_pair

        result = await lookup_cache(user_query, tenant_id=1)

        assert result is not None
        assert result.value == cached_sql
        assert result.metadata["match_type"] == "signature"
