import os
from unittest.mock import patch

from mcp_server.services.recommendation.config import load_recommendation_config


def test_config_defaults():
    """Test that defaults are returned when env vars are missing."""
    with patch.dict(os.environ, {}, clear=True):
        config = load_recommendation_config()
        assert config.limit_default == 3
        assert config.candidate_multiplier == 2
        assert config.fallback_enabled is True
        assert config.fallback_threshold == 0.85
        assert config.status_priority == ["verified", "seeded", "autogenerated", "unverified"]
        assert config.safety_enabled is False
        assert config.safety_max_pattern_length == 100
        assert config.safety_blocklist_regex is None
        assert config.safety_require_sanitizable is True


def test_config_overrides():
    """Test that valid env vars override defaults."""
    env = {
        "RECO_LIMIT_DEFAULT": "5",
        "RECO_CANDIDATE_MULTIPLIER": "3",
        "RECO_FALLBACK_ENABLED": "false",
        "RECO_FALLBACK_THRESHOLD": "0.5",
        "RECO_STATUS_PRIORITY": "verified, seeded",
        "RECO_SAFETY_ENABLED": "true",
        "RECO_SAFETY_MAX_PATTERN_LENGTH": "200",
        "RECO_SAFETY_BLOCKLIST_REGEX": ".*",
        "RECO_SAFETY_REQUIRE_SANITIZABLE": "false",
    }
    with patch.dict(os.environ, env):
        config = load_recommendation_config()
        assert config.limit_default == 5
        assert config.candidate_multiplier == 3
        assert config.fallback_enabled is False
        assert config.fallback_threshold == 0.5
        assert config.status_priority == ["verified", "seeded"]
        assert config.safety_enabled is True
        assert config.safety_max_pattern_length == 200
        assert config.safety_blocklist_regex == ".*"
        assert config.safety_require_sanitizable is False


def test_config_invalid_limit():
    """Test fallback for invalid limit."""
    with patch.dict(os.environ, {"RECO_LIMIT_DEFAULT": "invalid"}):
        config = load_recommendation_config()
        assert config.limit_default == 3

    with patch.dict(os.environ, {"RECO_LIMIT_DEFAULT": "-1"}):
        config = load_recommendation_config()
        assert config.limit_default == 3


def test_config_invalid_multiplier():
    """Test fallback for invalid multiplier."""
    with patch.dict(os.environ, {"RECO_CANDIDATE_MULTIPLIER": "0"}):
        config = load_recommendation_config()
        assert config.candidate_multiplier == 2


def test_config_invalid_threshold():
    """Test fallback for invalid threshold."""
    with patch.dict(os.environ, {"RECO_FALLBACK_THRESHOLD": "2.0"}):
        config = load_recommendation_config()
        assert config.fallback_threshold == 0.85

    with patch.dict(os.environ, {"RECO_FALLBACK_THRESHOLD": "abc"}):
        config = load_recommendation_config()
        assert config.fallback_threshold == 0.85


def test_config_priority_parsing():
    """Test list parsing for status priority."""
    with patch.dict(os.environ, {"RECO_STATUS_PRIORITY": "  A, B , c  "}):
        config = load_recommendation_config()
        assert config.status_priority == ["a", "b", "c"]

    with patch.dict(os.environ, {"RECO_STATUS_PRIORITY": "  "}):
        config = load_recommendation_config()
        assert config.status_priority == ["verified", "seeded", "autogenerated", "unverified"]


def test_config_invalid_safety_length():
    """Test fallback for invalid safety max pattern length."""
    with patch.dict(os.environ, {"RECO_SAFETY_MAX_PATTERN_LENGTH": "0"}):
        config = load_recommendation_config()
        assert config.safety_max_pattern_length == 100

    with patch.dict(os.environ, {"RECO_SAFETY_MAX_PATTERN_LENGTH": "invalid"}):
        config = load_recommendation_config()
        assert config.safety_max_pattern_length == 100
