import logging
import re
from typing import Optional

from mcp_server.models import CacheLookupResult
from mcp_server.services.registry import RegistryService

from .constraint_extractor import extract_constraints
from .sql_constraint_validator import validate_sql_constraints

logger = logging.getLogger(__name__)

# Conservative threshold to prevent serving wrong SQL for nuanced queries
SIMILARITY_THRESHOLD = 0.90
TENANT_LEAK_PATTERN = re.compile(r"(?i)\b(store_id|tenant_id)\s*=\s*['\"]?(\d+)['\"]?")


def _check_tenant_leak(sql: str, tenant_id: int) -> bool:
    """Check for hardcoded tenant IDs that differ from current."""
    matches = TENANT_LEAK_PATTERN.findall(sql)
    for _, val in matches:
        if int(val) != int(tenant_id):
            return True
    return False


async def lookup_cache(user_query: str, tenant_id: int) -> Optional[CacheLookupResult]:
    """Check cache using the Unified Registry.

    Tier 1: Fingerprint exact match (from registry)
    Tier 2: Vector similarity with constraint validation (from registry)
    """
    # === Tier 1: Canonical Registry Lookup (exact signature match) ===
    pair = await RegistryService.lookup_canonical(user_query, tenant_id)
    if pair and "cache" in pair.roles and pair.status != "tombstoned":
        # SAFETY: Validate even Tier-1 hits to catch subtle poisoning or stale entries
        constraints = extract_constraints(user_query)
        validation = validate_sql_constraints(pair.sql_query, constraints)
        if validation.is_valid:
            logger.info(f"✓ Registry signature hit: {pair.signature_key[:16]}...")
            metadata = {"match_type": "signature"}
            if pair.metadata and pair.metadata.get("schema_snapshot_id"):
                metadata["schema_snapshot_id"] = pair.metadata.get("schema_snapshot_id")
            return CacheLookupResult(
                cache_id=pair.signature_key,
                value=pair.sql_query,
                similarity=1.0,
                metadata=metadata,
            )
        else:
            reasons = "; ".join(m.message for m in validation.mismatches)
            msg = f"Tier-1 hit {pair.signature_key[:8]} failed validation"
            logger.warning(f"{msg}: {reasons}")
            # Fall through to semantic lookup

    # === Tier 2: Semantic Registry Fallback with Validation ===
    candidates = await RegistryService.lookup_semantic(
        user_query, tenant_id, threshold=SIMILARITY_THRESHOLD, limit=3, role="cache"
    )

    if not candidates:
        return None

    # Extract constraints for deterministic validation
    constraints = extract_constraints(user_query)

    for cand in candidates:
        if cand.status == "tombstoned":
            continue

        # 1. Safety Check: Cross-tenant leak
        if _check_tenant_leak(cand.sql_query, tenant_id):
            logger.warning(f"Rejecting candidate {cand.signature_key[:8]}: Tenant leak")
            continue

        # 2. Deterministic Validation
        validation = validate_sql_constraints(cand.sql_query, constraints)
        if validation.is_valid:
            logger.info(f"✓ Validated Registry hit: {cand.signature_key[:16]}...")
            metadata = {"match_type": "semantic"}
            if cand.metadata and cand.metadata.get("schema_snapshot_id"):
                metadata["schema_snapshot_id"] = cand.metadata.get("schema_snapshot_id")
            return CacheLookupResult(
                cache_id=cand.signature_key,
                value=cand.sql_query,
                similarity=0.95,  # Estimated
                metadata=metadata,
            )
        else:
            reasons = "; ".join(m.message for m in validation.mismatches)
            logger.debug(f"Rejecting candidate {cand.signature_key[:8]}: {reasons}")

    return None


async def update_cache(
    user_query: str, sql: str, tenant_id: int, schema_snapshot_id: Optional[str] = None
):
    """Write a new confirmed SQL generation to the Registry with 'cache' role."""
    metadata = {}
    if schema_snapshot_id:
        metadata["schema_snapshot_id"] = schema_snapshot_id
    await RegistryService.register_pair(
        question=user_query,
        sql_query=sql,
        tenant_id=tenant_id,
        roles=["cache"],
        status="autogenerated",
        metadata=metadata,
    )
    logger.info(f"✓ Registered cache entry for tenant {tenant_id}")


async def tombstone_cache_entry(cache_id: str, tenant_id: int, reason: str) -> bool:
    """Mark a cache entry as tombstoned in the registry.

    Args:
        cache_id: The signature_key of the entry.
        tenant_id: Tenant scope.
        reason: Why it's being marked invalid.
    """
    return await RegistryService.tombstone_pair(cache_id, tenant_id, reason)


async def get_cache_stats(tenant_id: Optional[int] = None) -> dict:
    """Return a placeholder for cache statistics."""
    return {"status": "Registry-based stats pending implementation"}
